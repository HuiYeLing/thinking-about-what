#include<bits/stdc++.h>
using namespace std;
int main()
{
        long long int a[30][30]={0}; // 创建一个二维数组a来表示棋盘
        long long int n,m; // n和m分别表示棋盘的行数和列数
        cin >> n >> m; // 读入n和m
        long int x,y; // x和y分别表示马的位置
        cin >> x >> y; // 读入x和y
        for (int  i = 0; i <=n; i++) // 遍历棋盘的每一行
        {
            for (int j = 0; j<=m; j++) // 遍历棋盘的每一列
            {
                a[i][j]=1; // 将所有点的值设为1，表示这些点都是可达的
            }
            
        }
        a[x][y]=0; // 将马的位置的值设为0，表示这个点不可达
        // 下面的一系列if语句是检查马的所有可能的控制点，并将这些点的值设为0，表示这些点不可达
        if (x+2<=n && y-1>=0)
        {
            a[x+2][y-1]=0;
        }
        if (x+2<=n && y+1<=m)
        {
            a[x+2][y+1]=0;
        }
        if (x+1<=n && y+2<=m)
        {
            a[x+1][y+2]=0;
        }
        if (x-1>=0 && y+2<=m)
        {
            a[x-1][y+2]=0;
        }
        if (x-2>=0 && y+1<=m)
        {
            a[x-2][y+1]=0;
        }
        if (x-2>=0 && y-1>=0)
        {
            a[x-2][y-1]=0;
        }
        if (x-1>=0 && y-2>=0)
        {
            a[x-1][y-2]=0;
        }
        if (x+1<=n && y-2>=0)
        {
            a[x+1][y-2]=0;
        }
        for (int  i = 0; i <=n; i++) // 遍历棋盘的每一行
        {
                for ( int j = 0; j <=m; j++) // 遍历棋盘的每一列
                {
                     if (i==0 && j==0) // 如果是棋盘的左上角，跳过
                     {
                         continue; 
                     }
                     if (a[i][j]==0) // 如果当前位置是马的位置或马的控制点，跳过
                     {
                        continue;
                     }
                     if (i==0) // 如果在第一行，只能从左边来
                     {
                       a[i][j]=a[i][j-1];
                     }
                     else if (j==0) // 如果在第一列，只能从上边来
                     {
                        a[i][j]=a[i-1][j];
                     }
                     else // 其他情况，可以从左边或上边来
                        {
                         a[i][j]=a[i-1][j]+a[i][j-1];
                        }
                }
                
        }
        cout << a[n][m]; // 输出从棋盘的左上角到右下角的所有可能路径的数量
}